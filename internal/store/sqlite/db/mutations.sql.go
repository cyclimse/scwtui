// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: mutations.sql

package db

import (
	"context"
)

const deleteResource = `-- name: DeleteResource :one
DELETE FROM resources
WHERE id = ?
RETURNING resources.id
`

func (q *Queries) DeleteResource(ctx context.Context, id interface{}) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, deleteResource, id)
	err := row.Scan(&id)
	return id, err
}

const upsertResource = `-- name: UpsertResource :one
INSERT INTO resources (
        id,
        name,
        project_id,
        description,
        tags,
        type,
        locality,
        json_data
    )
VALUES (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        json(?8)
    ) ON CONFLICT (id) DO
UPDATE
SET name = excluded.name,
    project_id = excluded.project_id,
    description = excluded.description,
    tags = excluded.tags,
    type = excluded.type,
    locality = excluded.locality,
    json_data = excluded.json_data
WHERE resources.id = excluded.id
RETURNING resources.type,
    resources.json_data AS data
`

type UpsertResourceParams struct {
	ID          interface{}
	Name        interface{}
	ProjectID   interface{}
	Description interface{}
	Tags        interface{}
	Type        int64
	Locality    interface{}
	Data        interface{}
}

type UpsertResourceRow struct {
	Type     int64
	JsonData interface{}
}

func (q *Queries) UpsertResource(ctx context.Context, arg UpsertResourceParams) (UpsertResourceRow, error) {
	row := q.db.QueryRowContext(ctx, upsertResource,
		arg.ID,
		arg.Name,
		arg.ProjectID,
		arg.Description,
		arg.Tags,
		arg.Type,
		arg.Locality,
		arg.Data,
	)
	var i UpsertResourceRow
	err := row.Scan(&i.Type, &i.JsonData)
	return i, err
}
